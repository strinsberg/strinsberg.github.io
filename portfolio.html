<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="https://latex.now.sh/style.css">
<link rel="stylesheet" href="/css/style.css">

  <script src="https://cdn.jsdelivr.net/npm/scittle@0.6.15/dist/scittle.js" type="application/javascript"></script>

  <script type="application/x-scittle">
  (defn local-storage? []
    (let [test 'test']
      (try
       (.setItem js/localStorage test test)
       (.removeItem js/localStorage test)
       true
       (catch js/Error e false))))

  (defn toggle-dark-mode []
   (when (local-storage?)
      (let [dark (.getItem js/localStorage "dark")]
        (if (or (nil? dark) (identical? dark "off"))
          (do
           (.setItem js/localStorage "dark" "on")
           (.add js/document.body.classList "latex-dark"))
          (do
           (.setItem js/localStorage "dark" "off")
           (.remove js/document.body.classList "latex-dark"))))))

  (defn set-mode []
   (when (local-storage?)
      (let [dark (.getItem js/localStorage "dark")]
        (when (and (not (nil? dark)) (identical? dark "on"))
           (.add js/document.body.classList "latex-dark")))))

  ;; export functions to use from JavaScript
  (set! (.-toggle_dark_mode js/window) toggle-dark-mode)
  (set! (.-set_mode js/window) set-mode)
</script>

  <title>Steven's Portfolio</title>
</head>

<body class="libertinus" onload="set_mode()">
  <h1 id="stevens-portfolio">Steven‚Äôs Portfolio
<button class="mode-button smaller"
        onclick="toggle_dark_mode()"
        title="Toggle light and dark mode">üåó</button>
</h1>
<div class="abstract">
<summary>
<p>This is a collection of my work and personal projects. It is still a
work in progress and I will add more descriptions, screenshots, and
demos where possible. In addition to finishing a Bachelor‚Äôs and Master‚Äôs
degree in computer science I have put countless hours into learning new
things.</p>
<p><br></p>
<p>You can find a little bit of everything here including interpreters,
compilers, software engineering research, and a video game or two. Most
of it was just done for learning purposes and for fun. A few things,
like my research and work experience, have some practical value. As for
the rest its value lies in what it taught me about technologies,
problem-solving, and what it takes to design and build software.
Enjoy!</p>
<p><br></p>
</summary>
<nav class="nav-list">
<p><a href="/index.html">Home</a> | <a
href="/portfolio.html">Portfolio</a> |
<a href="https://www.linkedin.com/in/steven-d-a8b954237" target="_blank">LinkedIn</a>
| <a href="https://github.com/strinsberg" target="_blank">GitHub</a></p>
</nav>

</div>
<h2 id="work-experience">Work Experience</h2>
<p>Given that have gone back to school and changed careers, I do not
have a lot of formal software engineering work experience. However, my
Master‚Äôs degree has been the better part of three years of work and I
treated it like a full time job as much as possible. After all, it was
paid for with funding and scholarships from the University of Lethbridge
and my supervisors.</p>
<p>I also had two jobs assisting with research projects during the
summers while at the University of Lethbridge. One was a more formal
development job where I rebuilt an educational web-based card game. Here
we followed software engineering practices with weekly standup-like
meetings, automated testing, documentation, and continuous integration
tools. The other job was less formal, and I spent most of the summer
writing Python scripts to automate collecting source code samples and
storing them in a simple database. However, it was important that the
tools I made were well documented and useable by future students.</p>
<h3 id="masters-thesis">Master‚Äôs Thesis</h3>
<p>I did my M.Sc. Computer Science at the University of Lethbridge
co-supervised by Dr.¬†Jackie Rice and Dr.¬†John Anvik. I investigated
using abstract syntax trees as a method of measuring a developer‚Äôs
experience with a piece of code. The abstract and a link to the thesis
are below. The code repository is not available yet as it needs some
cleaning up. I also plan on making a separate page with more information
along with the slides and transcript of my short thesis presentation
that introduces some of the more interesting results. For now if you are
interested in the results you will have to look at the thesis.</p>
<div class="abstract">
<h3>
Measuring Developer Experience with Abstract Syntax Trees
</h3>
<h4>
Abstract
</h4>
</div>
<blockquote style="text-align: justify;">
Accurately representing a developer‚Äôs programming knowledge and
experience is difficult. Traditional metrics rely on counting the number
of times a developer has used or made changes to pieces of code. When a
developer has modified a file in the past they are less likely to
introduce defects with a change. However, these metrics do not contain
any general information on the structure or purpose of a piece of code
and are only useful when developers work on a piece of code more than
once. We investigated the use of several new metrics based on abstract
syntax trees (ASTs) as a possible way to more completely measure a
developer‚Äôs experience. By using the ASTs of code previously modified by
a developer we may be able to identify their experience with a piece of
code they are modifying even if they have never modified that specific
code before. Through statistical analysis and machine learning
predictions we show that AST-based metrics capture a more general
programming experience than count-based metrics. In their current form,
AST-based metrics do not offer any significant improvements over
existing metrics for defect prediction. However, our work offers a
starting point for future use of ASTs for representation of knowledge
and experience in defect prediction and other relevant areas.
</blockquote>
<p><a href="https://hdl.handle.net/10133/6638" target="_blank">Thesis</a></p>
<p><em>GitHub Link Coming Soon</em>
<!--[Github](https://github.com/strinsberg/masters)--></p>
<h3 id="program-wars">Program Wars</h3>
<p><a href="https://github.com/strinsberg/Program-Wars" target="_blank">GitHub</a></p>
<p><a href="https://program-wars.firebaseapp.com" target="_blank">Play
The Game</a></p>
<h3 id="sociolinguistics-research-data-collection">Sociolinguistics
Research Data Collection</h3>
<p><a href="https://github.com/strinsberg/slrg_data" target="_blank">GitHub</a></p>
<h2 id="personal-projects">Personal Projects</h2>
<p>Since discovering computer programming I have built a lot of things
for fun and learning. I have listed many of them below. Some are more
finished than others and a few are school projects or extensions of
school projects. A few of them are even somewhat useful üòÅ.</p>
<h3 id="interpreters-compilers-and-vms">Interpreters, Compilers, and
VMs</h3>
<p>If there is one computer science topic I love the most it is
programming languages and their implementations. The simple fact that I
can give the computer instructions is pretty amazing, but combine that
with all the abstractions and paradigms that can be added on top of
those simple instructions. As a result I have spent a fair amount of
time implementing and adjusting programming languages.</p>
<p>I really enjoy Lisp-like languages and this is where many of my
personal attempts at interpreters and compilers have been focused.
Lisp-like languages are also slightly more straightforward to parse,
which can make them easier to get started with. With that simplicity
comes a lot of power though and a lot of room for fun or practical
extensions.</p>
<p>In the end though all of my projects are only for fun and personal
learning. I am sure it is possible to make an efficient, full-featured,
and robust programming language on my own, but it is not really
practical. There are so many amazing languages out there that many
people have spent many years refining. So, each of my projects have only
been taken so far.</p>
<h4 id="rusp">Rusp</h4>
<p>Rusp is an interpreter for a lisp-like language that I am working on.
It will be somewhat like a mashup between Clojure and Scheme, but with
some of my own syntax and built-in functions. While it is not terribly
practical to try to design a new language, it is unlikely that it is a
language that will ever see any real world use. Many smart people have
worked for many years to make high quality, robust languages. So, I get
to learn from those and experiment and learn even more from my successes
and failures.</p>
<p>I have not been able to work on it for a while, and it is not super
far along with functionality, but Rusp is my current side project. Most
of the time so far has been setting up the data structures and basic
compiler loop. I need a new implementation of macros to allow adding
some basic lisp forms in a simpler way than hard coding them in Rust.
Before I get too ahead of myself I want to solidify some of the design
details and create a test spec independent of Rust to drive future
development (See <a href="#clint">Clint</a>).</p>
<p>One of my other major goals is to compile Rusp directly to Rust. This
would not be a full interop style compilation like Clojure has, but it
would enable a Rusp project to be compiled to a native binary. Compiled
programs would still need to include a Rusp library for the lisp data
structures, but it would not bundle the full interpreter into the
runtime. Either way it is not something I will get to in the near
future. Just a fun project for the future.</p>
<p><a href="https://github.com/strinsberg/rusp" target="_blank">GitHub</a></p>
<h4 id="scheme">Scheme</h4>
<p>As a precursor to Rusp I made a Scheme interpreter in Rust following
the r5rs standard. I did not implement the whole standard. Most notably
some number and math stuff is missing along with macros and
continuations. I did refactor the interpreter to accommodate
continuations, which was not trivial (at least for me), and never got
around to adding them. I did get many of the built-in functions added,
but it is not a full implementation.</p>
<p>In the end this project became a place where I learned how I could
set up the lisp data structures in Rust. I moved on to work on Rusp
which uses some of the data structures and algorithms, but is no longer
Scheme.</p>
<p>I also learned how to use WASM to compile the interpreter and embed
it in a web page. So, I will be adding a demo of the interpreter to my
site. Then people can just try it out to see how well it works rather
than having to take my word for it or read my code. Of course, it is
just really cool that it is possible to make a project like this
available on the web. How easy it is to do with Rust is one thing that
will keep me coming back to Rust for future projects.</p>
<p><a href="https://github.com/strinsberg/my-scheme" target="_blank">GitHub</a></p>
<p><em>Web Demo Coming Soon</em> <!--[Try It](/)--></p>
<p><a href="https://github.com/strinsberg/scheme-interpreter" target="_blank">Original
School Project GitHub</a></p>
<h4 id="lt-64-vm">Lt-64 VM</h4>
<p>A fun little virtual machine that I made that has a fixed size
memory. I also wrote an assembler for it and then wrote a simple lisp
interpreter in the assembly language. Of course, I eventually ran into a
bug I could not find the cause of and moved on. I would do many things
differently, but it was a fun project. I also set it up to compile
programs and append them to a copy of the interpreter in C which made it
possible to solve programming contest problems with my own vm and
language. Nothing like submitting 1000 lines of C code and a string of
bytes to an online judge to solve a trivial problem üòÇ.</p>
<p>The code is a bit of a mess because over time I moved the single file
vm into the assembler project and made edits to it that did not get
transferred back to the main project. So, it is not really useable.
However, I did learn many things about stack-based virtual machines and
could use that knowledge to build a better one in the future.</p>
<p><a href="https://github.com/strinsberg/lt64" target="_blank">GitHub</a></p>
<p><a href="https://github.com/strinsberg/lt64-asm" target="_blank">Assembler
GitHub</a></p>
<p><a href="https://github.com/strinsberg/ltsp" target="_blank">Ltsp
GitHub</a></p>
<h4 id="pascal-subset-compiler">Pascal Subset Compiler</h4>
<p>This is a project that came out of a compilers course I took during
my Bachelor‚Äôs degree. We had to write a compiler for a subset of Pascal
over the years. At the end of the semester before I started my summer
job I spent a few weeks trying to expand the compiler and the vm that
was provided. I rewrote the lexer and parser using Flex and Bison. The
goal was to set up the compiler to generate an abstract syntax tree that
I could them pass to a code generator. I wanted to be able to give
myself the option of compiling to different targets in the future. It
was mostly a success, but once work started I never got back to it. I
also, made a couple mistakes trying to extend the vm for passing
procedure arguments and the code got out of hand (though it was an
ambitious project, so probably this should have been expected). I never
got back to it and moved on to other projects, but again it was a
wonderful learning experience.</p>
<p><a href="https://github.com/strinsberg/plcc" target="_blank">GitHub</a></p>
<p><a href="https://github.com/strinsberg/pl_compiler" target="_blank">Original
School Project GitHub</a></p>
<h3 id="command-line-tools">Command Line Tools</h3>
<p>I have also made a few command line programs and tools over the years
to help me accomplish a task or just to learn something and practice
programming. I don‚Äôt often have a need that cannot be met by an existing
project, but it is fun to be able to build something useful.</p>
<h4 id="easy-mark">Easy Mark</h4>
<p>I really enjoyed using Crowd Mark for marking in a few of my classes
as a teaching assistant. However, very few of the classes I marked for
used it. During the pandemic all assignments went virtual and this meant
providing feedback by annotating PDFs. I decided at some point to write
a tool that could make things a little easier for me. It mimicked Crowd
marks ability to save comments and their deductions so that I could
re-use them when many students had the same issue. Then I could just add
the assignment questions and marks and for each student enter feedback
for each question and let the program keep track of their marks. Once I
was finished the tool spit out a latex document with the students marks
and feedback that I compiled and uploaded. It saved me a lot of time and
felt good to use my skills to actually help me get my work done. It was
not perfect and by no means a replacement for Crowd Mark, but it did the
trick.</p>
<p><a href="https://github.com/strinsberg/easy-mark" target="_blank">GitHub</a></p>
<h4 id="clint-cli-integration-testing">Clint (cli integration
testing)</h4>
<p>This is another program that I will continue actively working on. I
originally built it to allow easily testing the <a
href="#lt-64">lt-64</a> vm. Because lt-64 was written in C it was not as
easy to set up unit testing, and maybe not practical given the way the
vm was constructed. So, I instead tested it by running the interpreter
on bytes using a Python script. This allowed me to write a bunch of
tests for different op-codes and features ahead of time and run them
against the interpreter as I built it. It was also nice to use as when
tests failed it would not stop running. So, I could write a lot of tests
beforehand and implement whichever one I wanted and just see which ones
would pass.</p>
<p>I assume that this is possible with more modern built-in testing
frameworks, but this worked well when those were not available. I liked
it so much that for command line programs I intend to keep using it and
fine-tuning it for my needs. Having a testing tool that is language
agnostic and runs tests without worrying about the implementation
details is useful. It makes doing TDD much easier in my opinion. With
built-in unit tests you have to know how you want to build your classes
or functions already. For personal projects things are much more like
prototypes and implementation and architecture change all the time. It
is often not practical to do TDD in the situations and can just waste
time if you scrap large portions of the code and implement them from
scratch.</p>
<p>For projects like Rusp this kind of testing also allows me to write a
language design spec in markup or code ahead of any implementation. If
the language changes I can change the spec and not worry about the
implementation details. It would also be possible to completely change
the implementation language or environment and the spec would need
little to no changes. And like most of my other projects, I get to
contemplate an important software engineering topic and learn new
things.</p>
<p><a href="https://github.com/strinsberg/clint" target="_blank">GitHub</a></p>
<h4 id="hockey-stats-viewer">Hockey Stats Viewer</h4>
<p>This should just be an SQL database lol. However, having it on my
first resume may have gotten me my first programming job, so it was
worth it. It is written in AWK, which was useful and not a bad idea, but
also not the best technology for this type of project. However, at the
time it gave me a tool that had some use when I was in a fantasy hockey
league to filter players with the best stat spread for our league setup.
I may have even won the year I used it during my draft, but I don‚Äôt
remember. It was a good learning experience, and the first program I
wrote that accepted a config file, so it was worth it (beyond getting me
a job). Plus, a professor once overheard me describing it to some
friends and asked incredulously ‚ÄúYou write programs in AWK?‚Äù, which gave
us all a good laugh.</p>
<p><a href="https://github.com/strinsberg/hockey-stats" target="_blank">GitHub</a></p>
<h4 id="simple-text">Simple Text</h4>
<p>I wrote an ncurses command line editor, and it worked! Like many of
these projects it was just for fun and learning. I did everything as
simply as I could, and I am sure if you opened a large file it would
crash or freeze. So, no need to ditch Nano, Vim, Emacs, or VsCode
anytime soon.</p>
<p><a href="https://github.com/strinsberg/simple-text" target="_blank">GitHub</a></p>
<h3 id="games-and-game-engines">Games And Game Engines</h3>
<p>Like everyone that has learned to program I have made a few video
games. I find I am generally more interested in creating the games
architecture and algorithms than I am in writing a compelling and fun
video game. As a result I have not really spent that much time making
video games. Below are two projects that I put the most time and effort
into.</p>
<h4 id="dgsl">DGSL</h4>
<p>This is another project that was born out of a class project. We were
supposed to build a text adventure game and use OOP design principles. I
took this a little too far and basically built a text adventure game
engine rather than just a game. In the summer I rewrote it in Python as
C++ made some things in my design a little cumbersome (or my design made
C++ cumbersome?). The goal was to create a program that would allow
people to somewhat easily create their own text adventure games without
needing to code. I built a world editor with Python and Tkinter that did
allow creating games, but I am not sure the result was all that
user-friendly. It was fun though, and it truly could be used to make at
least one type of text adventure game with a few updates to the engine
for things like saving games.</p>
<p>This was my first attempt at using a GUI framework. It was also
required making language agnostic data to pass between the world editor
and the program. If you made a sufficiently complex game it would have
spit out a nice big JSON file.</p>
<p>I also got some more experience with unit testing. The engine was
nearly fully unit tested, though I may have gotten too excited about
‚Äúmocking‚Äù things out. I am really not sure that the tests were as useful
as they could have been. However, you have to do something to learn that
you could do it better.</p>
<p><a href="https://github.com/strinsberg/dgsl-text-adventure-engine" target="_blank">Engine
GitHub</a></p>
<p><a href="https://github.com/strinsberg/dgsl-world-editor" target="_blank">World
Builder GitHub</a></p>
<p><a href="https://github.com/strinsberg/good-ship-lethbridge" target="_blank">Original
School Project GitHub</a></p>
<h4 id="space-match-3000">Space Match 3000</h4>
<p>This is one of my earliest programming attempts. It is a very simple
game that I wrote because I wanted to try writing some algorithms to
deal with a match 3 board. I even ended up using the state pattern to
make switching between game modes easier. The most important thing about
it was that it was technically finished and worked if I compiled it for
Linux and for my friends on Windows (thanks to the Love2d framework).
And now it is mostly playable online as well thanks to someone‚Äôs WASM
compiler. Though the UI design is not user-friendly, using keybinds to
select menu elements and the mouse to play the actual game. And you
can‚Äôt save games online. But I finished it, and it worked, and it did
what it was expected to do, and seemingly with few to no bugs. I even
learned that spelling mistakes are far more costly in a language like
Lua where every variable is set to nil even if it has never been
declared before. Nothing like 4 hours of debugging to find you got two
letters in a variable name swapped üò¢.</p>
<p><a href="https://github.com/strinsberg/space-match-3000" target="_blank">GitHub</a></p>
<p><a href="https://strinsberg.github.io/space-match-3000/" target="_blank">Play
The Game</a></p>
<h3 id="others">Others</h3>
<p>Finally, some other projects that I have worked on over the years.
These include some of my competitive programming solutions and some
other school projects.</p>
<h4 id="competitive-programming">Competitive Programming</h4>
<p>I was on a competitive programming team for two years while doing my
Bachelor‚Äôs degree at the University of Lethbridge. Honestly, it was not
my strong suit. I am more of a slow contemplative problem solver and to
be really successful at one needs to be fast. It was really fun and I
thoroughly enjoyed spending time with the other students and the coach
Howard Cheng. I even met several of my best friends there. I continued
to be involved during my Master‚Äôs (as much as was possible during the
Pandemic), but could no longer compete. And even if it was not my style
of activity I did learn a lot from it and get invaluable practice
solving problems. It does really compliment the academic environment and
personal projects.</p>
<p>The linked repo contains some of my solutions. Most of my solutions
were done on school computers and not saved to my GitHub. However, I
will continue adding them as I do them for interview prep and for fun
when I want a break from building larger personal projects. I do have
most of one year‚Äôs Advent of Code solutions and some solutions from a
course taught at ULeth focusing on contest programming style
problem-solving.</p>
<p><a href="https://github.com/strinsberg/competitive-programming" target="_blank">GitHub</a></p>
<h4 id="issue-tracker-rest-api">Issue Tracker REST API</h4>
<p>A school project where we built a REST API in C++ and a simple web
client to access it. The project was also done to try and simulate Agile
development. We did it in teams of 3 and had to present proposals and do
three bi-weekly standup meetings where we presented our progress to our
class. The goal was to identify all of our goals for each two-week
sprint and talk about what we achieved and didn‚Äôt and discuss our plan
for the next sprint. The API is quite simple, but it takes requests from
the website and stores or returns issue information. It was a fun
project and a good opportunity to learn some things about the software
development lifecycle. It was also fun to work on a project that was not
that is very applicable to the world of software development. Though
there are definitely easier technologies to build rest services with
than C++ üòâ.</p>
<p><a href="https://github.com/strinsberg/tracker-express" target="_blank">GitHub</a></p>
<h4 id="command-line-card-games">Command Line Card Games</h4>
<p>A couple of school projects where we had to implement some card games
for the command line. These focused on using OOP design, doing unit
testing and mocking, and using continuous integration tools to automate
testing, code coverage, and style checkers. One of the projects we were
given code written by other students for one card game and had to try to
use OOP to extend it to add another card game with as much code reuse as
was practical. Like many of the school projects these were good learning
experience, but were very simple and difficult to really sink your teeth
into the principles involved.</p>
<p><a href="https://github.com/strinsberg/card-game-extravaganza" target="_blank">Rummy
Extension GitHub</a></p>
<p><a href="https://github.com/strinsberg/old-maid" target="_blank">Old
Maid GitHub</a></p>

  <div>
  <br>
  <hr>
  ¬© Steven Deutekom 2023
  <br>
  Styled with <a href="https://latex.now.sh/">latex.css</a>
</div>

</body>

</html>
